/** basic **/
#include <thread>
#include <iostream>
#include <string>
#include <vector>
#include <thread>
#include <tuple>
#include <numeric>
/** ros **/
#include <ros/ros.h>
#include <ros/package.h>
#include <rosbag/bag.h>
#include <rosbag/view.h>
#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/PointCloud.h>
#include <sensor_msgs/point_cloud_conversion.h>
/** pcl **/
#include <pcl/common/common.h>
#include <pcl/common/time.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_types.h>
#include <pcl/filters/filter.h>
#include <pcl/filters/conditional_removal.h>
#include <pcl/filters/radius_outlier_removal.h>
#include <pcl/filters/uniform_sampling.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/kdtree/kdtree_flann.h>
#include <pcl/common/transforms.h>
#include <pcl/features/normal_3d.h>
#include <pcl/features/normal_3d_omp.h>
#include <pcl/registration/gicp.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <Eigen/Core>
/** opencv **/
#include <opencv2/opencv.hpp>
/** headings **/
#include <define.h>
/** namespace **/
using namespace std;

class LidarProcess{
public:
    /** essential params **/
    string topic_name;
    string kPkgPath = ros::package::getPath("cocalibration");
    string dataset_name;
    string kDatasetPath;
    int spot_idx = 0;
    int view_idx = 0;
    int num_spots = 1;
    int num_views = 1; /** note: each spot contains several view **/
    int view_angle_init = 0;
    int view_angle_step = 1;
    int center_view_idx = 0;

    /** const parameters - original data - images and point clouds **/
    const int kFlatRows = 2000;
    const int kFlatCols = 4000;
    const float kRadPerPix = (M_PI * 2) / kFlatCols;
    const bool kColorMap = false; /** enable edge cloud output in polar/3D space for visualization **/

    /** tags and maps **/
    typedef vector<int> Tags;
    typedef vector<vector<Tags>> TagsMap;
    vector<vector<TagsMap>> tags_map_vec; /** container of tagsMaps of each pose **/

    /** spatial coordinates of edge points (center of distribution) **/
    // extracted edges in original space
    vector<vector<EdgeCloud>> edge_cloud_vec; /** container of edgeClouds of each pose **/

    /** rigid transformation generated by ICP at different poses(vertical angle) **/
    vector<vector<Eigen::Matrix4f>> pose_trans_mat_vec;

    /***** Extrinsic Parameters *****/
    Ext_D ext_;

    /** File Path of the Specific Scene **/
    struct PoseFilePath {
        PoseFilePath()= default;
        PoseFilePath(string& spot_path, string& pose_path) {
            this->recon_folder_path = spot_path + "/recon";
            this->output_folder_path = pose_path + "/outputs/lidar_outputs";
            this->bag_folder_path = pose_path + "/bags";
            this->result_folder_path = pose_path + "/results";

            this->edge_img_path = pose_path + "/edges/lidar_edge.png";
            this->view_cloud_path = this->output_folder_path + "/view_cloud.pcd";
            this->pose_trans_mat_path = this->output_folder_path + "/pose_trans_mat.txt";
            this->flat_img_path = this->output_folder_path + "/flat_lidar_image.bmp";
            this->tags_map_path = this->output_folder_path + "/tags_map.txt";
            this->edge_cloud_path = this->output_folder_path + "/edge_lidar.pcd";
            this->edge_fisheye_projection_path = this->output_folder_path + "/lid_trans.txt";
            this->params_record_path = this->output_folder_path + "/params_record.txt";
            
            this->lio_spot_trans_mat_path = this->recon_folder_path + "/lio_spot_trans_mat.txt";
            this->icp_spot_trans_mat_path = this->recon_folder_path + "/icp_spot_trans_mat.txt";
            this->spot_cloud_path = this->recon_folder_path + "/spot_cloud.pcd";
            this->spot_rgb_cloud_path = this->recon_folder_path + "/spot_rgb_cloud.pcd";
        }
        /** pose **/
        string output_folder_path;
        string result_folder_path;
        string bag_folder_path;

        string edge_img_path;
        string view_cloud_path;
        string pose_trans_mat_path;
        string flat_img_path;
        string tags_map_path;
        string edge_cloud_path;
        string edge_fisheye_projection_path;
        string params_record_path;
        /** spot **/
        string recon_folder_path;
        string spot_cloud_path;
        string fullview_sparse_cloud_path;
        string spot_rgb_cloud_path;
        string lio_spot_trans_mat_path;
        string icp_spot_trans_mat_path;
    };
    vector<vector<string>> folder_path_vec;
    vector<vector<struct PoseFilePath>> file_path_vec;

    /** Degree Map **/
    std::map<int, int> degree_map;

public:
    /***** LiDAR Class *****/
    LidarProcess();
    void setSpot(int spot_idx) {
        this->spot_idx = spot_idx;
    }
    void setView(int view_idx) {
        this->view_idx = view_idx;
    }

    /***** Point Cloud Generation *****/
    void bagToPcd(string filepath, CloudI &cloud);

    /***** LiDAR Pre-Processing *****/
    void lidarToSphere(CloudI::Ptr &cart_cloud, CloudI::Ptr &polar_cloud);
    void sphereToPlane(CloudI::Ptr &polar_cloud);
    void generateEdgeCloud(CloudI::Ptr &cart_cloud);

    /***** Edge Process *****/
    void edgeExtraction();
    void ReadEdge();

    /***** Registration and Mapping *****/
    Mat4F alignCloud(CloudI::Ptr cloud_tgt, CloudI::Ptr cloud_src, Mat4F init_trans_mat, int cloud_type, const bool kIcpViz);
    void getEdgeDistance(EdgeCloud::Ptr cloud_tgt, EdgeCloud::Ptr cloud_src, float max_range);

    void generateViewCloud();
    void stitchViewCloud();
    void generateSpotCloud();
    void stitchSpotCloud();
    void stitchFineToCoarse();
    void generateColoredFineMap(bool kGlobalUniformSampling);
    void generateFineMap(bool kGlobalUniformSampling);

    double getFitnessScore(CloudI::Ptr cloud_tgt, CloudI::Ptr cloud_src, float max_range);
    void removeInvalidPoints(CloudI::Ptr cloud);

    void computeCovariances(pcl::PointCloud<PointI>::ConstPtr cloud,
                            const pcl::search::KdTree<PointI>::Ptr kdtree,
                            MatricesVector& cloud_covariances);

};
